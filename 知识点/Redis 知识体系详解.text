# Redis 知识体系详解

## 一、Redis 数据类型及应用场景

### 基本数据类型
1. **String**：
   - 底层结构：SDS (Simple Dynamic String)
   - 应用场景：缓存、计数器、分布式锁

2. **Hash**：
   - 底层结构：ziplist 或 hashtable
   - 应用场景：存储对象属性（如用户信息）

3. **List**：
   - 底层结构：ziplist 或 linkedlist
   - 应用场景：消息队列、最新消息排行

4. **Set**：
   - 底层结构：intset 或 hashtable
   - 应用场景：共同好友、抽奖

5. **ZSet**：
   - 底层结构：ziplist 或 skiplist+dict
   - 应用场景：排行榜、延迟队列

### 高级数据类型
- Bitmaps：位图统计
- HyperLogLog：基数统计
- GEO：地理位置

## 二、底层数据结构详解

1. **SDS**：二进制安全，预分配空间，O(1)获取长度
2. **ziplist**：连续内存存储，节省空间
3. **skiplist**：
   - 平均O(logN)查询效率
   - 实现简单，比平衡树更容易维护
   - 范围查询高效

## 三、分布式锁实现

### SETNX 实现的问题
1. 非原子性操作（设置值+过期时间）
2. 锁误删（其他客户端可能删除）
3. 不可重入
4. 无自动续期机制

### Redisson 实现
1. **数据结构**：Hash结构存储锁信息
   - Key：锁名称
   - Field：客户端ID+线程ID
   - Value：重入次数

2. **看门狗机制**：
   - 后台线程每10秒检查锁
   - 若持有锁则延长过期时间（默认30秒）

3. **优点**：
   - 可重入
   - 自动续期
   - 锁竞争公平（通过Redis队列）

## 四、持久化机制

| 方式 | 原理 | 优点 | 缺点 |
|------|------|------|------|
| RDB  | 定时快照 | 恢复快、体积小 | 可能丢数据 |
| AOF  | 记录写命令 | 数据安全 | 文件大、恢复慢 |
| 混合 | RDB+AOF | 结合两者优点 | 版本要求4.0+ |

## 五、缓存问题及解决方案

1. **缓存穿透**：
   - 现象：查询不存在数据
   - 解决：布隆过滤器、空值缓存

2. **缓存击穿**：
   - 现象：热点key过期
   - 解决：互斥锁、永不过期

3. **缓存雪崩**：
   - 现象：大量key同时失效
   - 解决：随机过期时间、多级缓存

4. **热Key问题**：
   - 影响：单节点负载过高
   - 解决：本地缓存、分片

5. **大Key问题**：
   - 影响：阻塞请求
   - 解决：拆分、压缩、异步删除

## 六、高可用架构

1. **主从复制**：
   - 全量同步：RDB文件传输
   - 增量同步：复制缓冲区

2. **哨兵模式**：
   - 监控、通知、自动故障转移
   - 至少3个实例保证健壮性

3. **Cluster集群**：
   - 16384个slot分片
   - 节点间gossip协议通信

4. **其他方案**：
   - Twemproxy
   - Codis

## 七、高级特性

1. **内存淘汰策略**：
   - volatile-lru/allkeys-lru
   - volatile-ttl/random
   - noeviction

2. **管道/Pipeline**：批量命令减少RTT
3. **Lua脚本**：原子性执行复杂操作

## 八、生产建议

1. 避免大Key（单个value不超过10KB）
2. 合理设置过期时间
3. 监控慢查询（slowlog）
4. 连接池配置（避免频繁创建连接）